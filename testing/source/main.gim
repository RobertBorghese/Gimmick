
import alt


start namespace dfsfds
var blafdfdsfd = 43434
@sortMembersAlphabetically
class AClass:
	var vwref = 666
	static aa = 32
	var fds = "fdsf"
	var bb = 123

	static def bla -> int:
		return aa

	def ccc -> int:
		return 0

	def bla2 -> int:
		return 0

var ffff = 2323232
end namespace

extern class Test:
	var bla: int

inline def bla432:
	var ffdfdf = 32

def Test54555(kf: Blah ):
	print("fdsf")

compiler attribute myAttribute(someInput: string, bla: string list):
	def toCpp -> string:
		someInput = bla[0];
		###if someInput.length() == 3:
			return "got something"
		else:
			return "got nothing"###
		return "test"

@myAttribute("fjdkl", ["dsa"]);

var a = 32

#@if(js == false) var b = bla2;

@untyped scope:
	d.df = 43
	if bfkld:
		print("FUDFKDL")

scope:
	if a == 32:
		a++

if a == 32:
	@untyped b::gf++

print("fd")

var fds: int ptr list

var fdsd = "fdsklfds"
var dsdsds: string = fdsd
var help = "";

var qwer = help

var aaa = 111.floor.floor

if 21 == 21:
	print("fds")

print(12.toString());

var blabla = ""
@if(js) blabla = "fds";
@elseif(js) blabla = "broken"
@else scope:
	blabla = "gfd"
	blabla = "success!"


print("bla");

print("bla23");

var grge = dfsfds.ffff

get test2 -> int:
set test2(bla: int):

def test1() -> int:
	return 0

#def test() -> int:

def test(test: int) -> int?:
	return null

def test(test2: long?) -> int?:
	return null

def test(test3: long = 0):

def test(test5: float = 0):

#def test(test: string):

var __ttgdf = test2


#modify string:
#	def bbb -> int:
#		return length

#var pop = "fjdsklfkds".bbb()

test(43f);

class MyTestClass:
	def test():
		unqiue++
		print("test")

	init(fd: int):
		unqiue = 32
		test();

	init(sdfsd: float):

	destroy:
		print("fjdklfds")
		unqiue++

	var unqiue



#class PleaseWork extends MyTestClass:

scope:
	var onetwo = 12f
	scope:
		var twothree = onetwo + 32

extern var llll: string;
#var qwere = llll ?? 43;

def qwetre(b: Blah):
	extern var cc: Blah;
	print(b.test)

#var blahinsta = Blah()

class Blah:
	var test = "fdfds"
	op ++:
		print("fdsfds")

	op +(a: int):
		print("test")

	op +(a: float):
		print("test")

	init(a: int): 
		print("fds")

	init(a: string):

	def one(a: int):

	def one(a: string):

var qqds = Blah("jfkdlsjsd");
qqds + 32
#qqds + 43.4
qqds++

qqds.one(435454)

Test54555(qqds);


var asasa: (int, int) list;

var lookforthis = qqds.test


def AAA:

class AAA:

#var ergfd = Blah.new

###
> This would turn:

print(23)
print(1.2, "hello")

> to:

std.cout << 23.toString() << std.endl
std.cout << 1.2.toString() << "hello".toString() << std.endl

> then, finally, to C++:

std::cout << std::to_string(23) << std::endl
std::cout << std::to_string(1.2) << "hello" << std::endl
###

###
macro print<T: has def toString() -> string>(args: T list):
	return "std.cout << " + args.map(a -> "(" + a + ").toString()").join(" << ") + " << std.endl";


macro createClass(name: string):
	var result = ""
	result += "class " + name + ":\n";
	result += "\tinit:\n";
	result += "\t\tprint(\"Created a \" + " + name + " + \");";
	return result;
###


###
class Blah<T: has [def toString() -> string, var hehe: int]>:
	def getGeneri -> T:


var bla = Blah<string>.new


def test<T: has def toString() -> string>(input: T) -> T:
###

def pweo<T: { has def blabla() -> int, has var hey: int }>:
	print("fdsfds")

###
pweo

pweo()
###
var dsfds2 = Popo!int(4)

class Popo<T = int>:
	init:
	init(test: int = 32):

var dsfds = Popo!int(4)

def qpos:

var kofdsk = qpos()

def pqpqp(a: int):

def pqpqp(a: string) -> int:
	return 2

#pqpqp("32.43")


var bla = (pqpqp("32.43"), 1)
